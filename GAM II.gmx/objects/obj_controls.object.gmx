<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>x = room_width * .5
control_x = x - 5
cursor_x = 5
vertical_padding = 10;
index = 0
max_index = 6
default_index = max_index - 1
menu_move_cooldown = room_speed * .15
editing_key = false
unbound = 0

keybinds[INPUT.LEFT] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.LEFT]))
keybinds[INPUT.RIGHT] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.RIGHT]))
keybinds[INPUT.DOWN] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.DOWN]))
keybinds[INPUT.JUMP] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.JUMP]))
keybinds[INPUT.BLINK] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.BLINK]))


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///menu cooldown
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if editing_key
{
    if keyboard_check_pressed(vk_anykey)
    {
        obj_input.keybinds[index] = keyboard_lastkey
        keybinds[index] = string_upper(scr_keycode_to_string(keyboard_lastkey))
        editing_key = false
        ini_open("keybinds.ini") 
        var key;
        switch(index)
        {
            case 0:
                key = "left"
            break;
            case 1:
                key = "right"
            break;
            case 2:
                key = "down"
            break;
            case 3:
                key = "jump"
            break;
            case 4:
                key = "blink"
            break;
        }
        ini_write_real("keys",key,keyboard_lastkey)
        ini_close()
        for(var i = 0; i &lt;= INPUT.BLINK; ++i)
        {
            if index != i &amp;&amp; obj_input.keybinds[i] = keyboard_lastkey
            {
                keybinds[i] = "NO KEY"
                ++unbound
            }
        }
        keyboard_clear(keyboard_lastkey)
        exit
    }
    else
        exit
}

if keyboard_check_pressed(vk_enter) || keyboard_check_pressed(vk_space)
{
    switch(index)
    {
        case default_index:
            file_delete("keybinds.ini")
            with(obj_input)
            {
                keybinds[INPUT.LEFT] = vk_left
                keybinds[INPUT.RIGHT] = vk_right
                keybinds[INPUT.DOWN] = vk_down
                keybinds[INPUT.JUMP] = vk_up
                keybinds[INPUT.BLINK] = ord("Z")
            }
            keybinds[INPUT.LEFT] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.LEFT]))
            keybinds[INPUT.RIGHT] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.RIGHT]))
            keybinds[INPUT.DOWN] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.DOWN]))
            keybinds[INPUT.JUMP] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.JUMP]))
            keybinds[INPUT.BLINK] = string_upper(scr_keycode_to_string(obj_input.keybinds[INPUT.BLINK]))
            unbound = 0
            break;
        case max_index:
            if unbound
            {
                obj_controller.screenshake = 1
                break
            }
            instance_destroy()
            instance_create(0,0,obj_mainmenu)
            break;
        default:
            if keybinds[index] = "NO KEY"
                --unbound
            keybinds[index] = "PRESS KEY"
            editing_key = true
    }
}

if alarm[0] &gt; 0 exit
if keyboard_check(vk_down)
{
    if ++index &gt; max_index
        index = 0
    alarm[0] = menu_move_cooldown
}
else if keyboard_check(vk_up)
{
    if --index &lt; 0
        index = max_index
    alarm[0] = menu_move_cooldown
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>y = 5

draw_set_halign(fa_center)
draw_text(x,y,"CONTROLS")
y += vertical_padding

draw_text(x,y,"ENTER TO EDIT KEYBIND")
y += vertical_padding

draw_set_halign(fa_right)
draw_text(control_x,y,"LEFT: ")
draw_set_halign(fa_left)
draw_text(control_x,y,keybinds[INPUT.LEFT])
y += vertical_padding

draw_set_halign(fa_right)
draw_text(control_x,y,"RIGHT: ")
draw_set_halign(fa_left)
draw_text(control_x,y,keybinds[INPUT.RIGHT])
y += vertical_padding

draw_set_halign(fa_right)
draw_text(control_x,y,"CROUCH: ")
draw_set_halign(fa_left)
draw_text(control_x,y,keybinds[INPUT.DOWN])
y += vertical_padding

draw_set_halign(fa_right)
draw_text(control_x,y,"JUMP: ")
draw_set_halign(fa_left)
draw_text(control_x,y,keybinds[INPUT.JUMP])
y += vertical_padding



draw_set_halign(fa_right)
draw_text(control_x,y,"ABILITY: ")
draw_set_halign(fa_left)
draw_text(control_x,y,keybinds[INPUT.BLINK])
y += vertical_padding

draw_set_halign(fa_center)
draw_text(x,y,"RESTORE DEFAULT")
y += vertical_padding

draw_text(x,y,"RETURN")
y += vertical_padding


var scale = -editing_key
if scale = 0 
    scale = 1
draw_sprite_ext(spr_menucursor,0,cursor_x,vertical_padding * (2 + index) + 7,scale,1,0,c_white,1)

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
